#include "_pch.hpp"

// ******************************
// *
// * 雞尾酒排序(Cocktail sort)：
// * 是氣泡排序的一種變形
// * 不同處在於排序時是以雙向在序列中進行排序
// *
// * 時間複雜度：
// * 最壞時間複雜度 O(n^2)
// * 最佳時間複雜度 O(n)
// * 平均時間複雜度 O(n^2)
// *
// * 空間複雜度：
// * 最壞空間複雜度
// * 總共 O(n)
// * 輔助 O(1)
// *
// ******************************

// 雞尾酒排序，也就是定向氣泡排序，雞尾酒攪拌排序，攪拌排序（也可以視作選擇排序的一種變形），
// 漣漪排序，來回排序或快樂小時排序，是氣泡排序的一種變形。
// 此演算法與氣泡排序的不同處在於排序時是以雙向在序列中進行排序。

// 雞尾酒排序等於是氣泡排序的輕微變形。不同的地方在於從低到高然後從高到低，
// 而氣泡排序則僅從低到高去比較序列裡的每個元素。他可以得到比氣泡排序稍微好一點的效能，
// 原因是氣泡排序只從一個方向進行比對（由低到高），每次循環只移動一個項目。
//
// 以序列(2,3,4,5,1) 為例，雞尾酒排序只需要存取一次序列就可以完成排序，
// 但如果使用氣泡排序則需要四次。但是在亂數序列的狀態下，雞尾酒排序與氣泡排序的效率都很差勁。

// * 雞尾酒排序(Cocktail sort)
template <typename T>
void CocktailSort(T arr[], int arr_size) {

    if (arr_size <= 0) { return; }

    int i;
    int left  = 0;
    int right = arr_size - 1;

    while (left < right) {

        // 大的往右
        for (i = left; i < right; ++i) {
            if (arr[ i ] > arr[ i + 1 ]) {
                swap(arr[ i ], arr[ i + 1 ]);
            }
        }
        --right;

        // 小的往左
        for (i = right; i > left; --i) {
            if (arr[ i - 1 ] > arr[ i ]) {
                swap(arr[ i - 1 ], arr[ i ]);
            }
        }
        ++left;
    }
}